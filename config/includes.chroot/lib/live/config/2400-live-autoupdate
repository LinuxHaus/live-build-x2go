#!/bin/sh

# this is not /bin/bash, so "echo -e" is not supported, but the default when calling "echo"

prepare_tempdir ()
{ # prepare temporary directory by filling it with the contents of our download folder
	# Now we'll copy the content of the X2Go-live-download folder to our tempdir
	# this is so we can run wget in update mode (-N) or rsync without needing
	# write access to our boot medium (write access means increased wear and tear,
	# and we want to avoid that especially for media that has no wear-leveling
	# like CF cards)
	#
	echo -n "\n$(date +'%F | %T | ')'$0': Preparing tempdir ..."
	while ! rsync -aPv --inplace --modify-window=1 $DOWNLOADPATH/ $TEMPDIR; do
		echo -n "\n$(date +'%F | %T | ')'$0': Sleeping 30 seconds ..."
		sleep 30
		echo -n "\n$(date +'%F | %T | ')'$0': Retrying ..."
	done
	echo " done."
}

check_timestamp ()
{ # this attempts to download a timestamp file
	echo -n "\n$(date +'%F | %T | ')'$0': starting timestamp download ..."
	if ! $DOWNLOADCOMMANDFORTIMESTAMP; then
		return 1
	else
		RUNNINGVERSION=$(stat -c %Y /lib/live/mount/rootfs/filesystem.squashfs/lib)
		if [ $RUNNINGVERSION -ge $(cat $TEMPDIR/x2go-tce-timestamp) ] ; then
			return 5
		fi
	fi
	return 0
}

show_versions ()
{ # this prints the TCE versions that are stored on the local medium to the log output
	LISTOFTIMESTAMPFILES=$(find /lib/live/mount/findiso/boot -name "x2go-tce-timestamp")
	if [ -n "$LISTOFTIMESTAMPFILES" ]; then
		echo -n "\n$(date +'%F | %T | ')'$0': List of locally stored TCE versions:"
		echo "--- BEGIN TIMESTAMPS ---" >/var/run/x2go-tce-timestamps
		for TIMESTAMPFILE in $LISTOFTIMESTAMPFILES; do 
			echo "$(basename $(dirname $TIMESTAMPFILE));$(cat $TIMESTAMPFILE);" >>/var/run/x2go-tce-timestamps
			echo -n "\n$(date +'%F | %T | ')'$0': $(basename $(dirname $TIMESTAMPFILE)) $(cat $TIMESTAMPFILE) - $(date --date=@$(cat $TIMESTAMPFILE))"
		done
		sed -i "s/$RUNNINGSYSTEMNAME;$/$RUNNINGSYSTEMNAME;X/i" /var/run/x2go-tce-timestamps
		echo "---- END TIMESTAMPS ----" >>/var/run/x2go-tce-timestamps
	fi
}

umount_or_remount_ro ()
{ # change mount back to ro and sync
	if [ -n "$NTFSROOT" ] || [ -n "$RAMDISKMODE" ] ; then
		if umount $MOUNTPOINT; then
			echo -n "\n$(date +'%F | %T | ')'$0': Unmounted '$MOUNTPOINT'."
		else
			echo -n "\n$(date +'%F | %T | ')'$0': Unable to unmount '$MOUNTPOINT'."
		fi
	else	
		if mount -oremount,ro,sync $MOUNTPOINT; then
			echo -n "\n$(date +'%F | %T | ')'$0': Remounted '$MOUNTPOINT' ro and sync."
		else
			echo -n "\n$(date +'%F | %T | ')'$0': Unable to remount '$MOUNTPOINT' ro and sync."
		fi
	fi

}

cleanup () 
{ # discard contents of tmpfs, umount if necessary
	if [ -n "$NTFSROOT" ]; then
		echo -n "\n$(date +'%F | %T | ')'$0': Removing '$TEMPDIR/*'."
		rm -rf $TEMPDIR/*
	else
		echo -n "\n$(date +'%F | %T | ')'$0': Unmounting '$TEMPDIR'."
		umount $TEMPDIR
	fi
	if rmdir $TEMPDIR; then
		echo -n "\n$(date +'%F | %T | ')'$0': Removed empty directory '$TEMPDIR'."
	else
		echo -n "\n$(date +'%F | %T | ')'$0': Could not remove directory '$TEMPDIR'."
	fi
	if [ -n "$NTFSROOT" ] || [ -n "$RAMDISKMODE" ] ; then
		if grep -q "$MOUNTPOINT" /proc/mounts ; then
			echo -n "\n$(date +'%F | %T | ')'$0': '$MOUNTPOINT' is mounted, attempting umount."
			if umount $MOUNTPOINT; then
				echo -n "\n$(date +'%F | %T | ')'$0': Unmounted '$MOUNTPOINT'."
			else
				echo -n "\n$(date +'%F | %T | ')'$0': Could not unmount '$MOUNTPOINT'."
			fi
		fi
	fi
}

LiveAutoUpdateMain ()
{
# Output startup message
#
echo -n " live-autoupdater (backgrounding update task)"


# Background everything
#
(

	while ! [ -c /dev/tty8 ] ; do
		echo -n "\n$(date +'%F | %T | ')'$0' is waiting for tty8 to become available."
		sleep 2
	done

	# redirect all output to first available VT console
	#
	exec >/dev/tty8 2>&1

	# This is so grep, awk and sed will match the right terms regardless of LANG
	#
	unset LANG
	unset LC_ALL
	unset LC_MESSAGES

	# Define our mountpoint and check if we're capable of auto-updating
	NTFSROOT=$(cat /proc/cmdline | tr ' ' '\n' | awk -F '=' '/^ntfs-uuid/ { print $2 }')
	if [ -n "$NTFSROOT" ]; then
		mkdir -p /lib/live/mount/ntfsroot
		# This is in case we've been passed an incomplete UUID and/or one with dashes
		# For example, "vol c:" on Windows will return the last 8 digits of the UUID
		# only, and separate them with a dash.
		if ! [ -L "/dev/disk/by-uuid/$NTFSROOT" ]; then
			NTFSROOT=$(echo $NTFSROOT | tr -d '-')
			if ! [ -L "/dev/disk/by-uuid/$NTFSROOT" ]; then
				NTFSROOT=$(basename $(echo /dev/disk/by-uuid/*$NTFSROOT | tr ' ' '\n' | head -1))
			fi
		fi

		if mount -t ntfs-3g -rw /dev/disk/by-uuid/$NTFSROOT /lib/live/mount/ntfsroot ; then
			echo -n "\n$(date +'%F | %T | ')'$0': Mounted '/dev/disk/by-uuid/$NTFSROOT'."
		else
			echo -n "\n$(date +'%F | %T | ')'$0': Unable to mount '/dev/disk/by-uuid/$NTFSROOT'."
		fi
		# TODO: Further error handling
		MOUNTPOINT="/lib/live/mount/ntfsroot/"
		# create a temporary directory
		TEMPDIR=$(mktemp -d --tmpdir=$MOUNTPOINT)
	else
		MOUNTPOINT="/lib/live/mount/findiso/"
		# create a temporary directory and mount a tmpfs there
		TEMPDIR=$(mktemp -d --tmpdir=/mnt)
		
		if [ -d /lib/live/mount/findiso/ ] ; then
			# if we have access to the entire filesystem, use the
			# directory size as base size for the current image - 
			# and if the download directory is even bigger, use that size
			IMGSIZE=$(du -s "/lib/live/mount/findiso/$(dirname $(sed -e 's/^.*findiso/findiso/' -e 's/ .*$//' /proc/cmdline | awk -F '=' '{ print $2 }'))" | awk '{ print $1}')
			IMGSIZEDOWNLOAD=$(du -s "/lib/live/mount/findiso/boot/X2Go-live-download" | awk '{ print $1}' || echo "0")
			[ $IMGSIZEDOWNLOAD -gt $IMGSIZE ] && IMGSIZE=$IMGSIZEDOWNLOAD
		else
			IMGSIZE=$(df /lib/live/mount/medium | awk ' /medium/ { print $2}')
		fi
		# multiply current size by 1.5 as safety margin
		mount -t tmpfs -osize=$((IMGSIZE*15/10))k tmpfs $TEMPDIR

	fi

	# determine our booted environment as well as the other available ones
	RUNNINGSYSTEMFULLPATH=$(dirname $(readlink -m "$MOUNTPOINT/$(cat /proc/cmdline | \
				tr ' ' '\n' | \
				awk -F'=' ' /^findiso=/ { print $2 }')"))

	ALLSYSTEMSROOT=$(dirname $RUNNINGSYSTEMFULLPATH)
	RUNNINGSYSTEMNAME=$(basename $RUNNINGSYSTEMFULLPATH)

	# download url pointing to directory with all required files goes here
	DOWNLOADURL=$(cat /proc/cmdline | \
		       tr ' ' '\n' | \
		       awk -F'=' ' /^updateurl=/ { print $2 }')

	if [ -z "$DOWNLOADURL" ]; then
		echo -n "\n$(date +'%F | %T | ')'$0': No update URL. Exiting."
		return 0
	fi

	if ! [ -d /lib/live/mount/findiso ] ; then
		echo -n "\n$(date +'%F | %T | ')'$0': '/lib/live/mount/findiso' directory not found. Scanning for partitions."
		LISTOFPARTITIONS=$(grep -H ^0$ /sys/block/*/removable | awk -F '/' '{ print $4 }' | xargs -n 1 -I XXX fdisk -l /dev/XXX 2>/dev/null | awk '$0 ~ /Linux$/ { print $1}')
		TEMPMOUNT=$(mktemp -d -p /lib/live/mount/)
		FINDFILE=$(cat /proc/cmdline | tr " " "\n" | awk -F '=' '$1 == "findiso" { print $2 }')
		[ -z "$FINDFILE" ] && exit 0
		for PARTITION in $LISTOFPARTITIONS ; do
			mount -oro $PARTITION $TEMPMOUNT
			if ! [ -f "$TEMPMOUNT/$FINDFILE" ] ; then
				umount $TEMPMOUNT
			else
				umount $TEMPMOUNT
				rmdir $TEMPMOUNT
				mkdir /lib/live/mount/findiso
				if mount -oro $PARTITION /lib/live/mount/findiso ; then
					echo -n "\n$(date +'%F | %T | ')'$0': mounted $PARTITION as '/lib/live/mount/findiso'."
					RAMDISKMODE="yes"
				else
					echo -n "\n$(date +'%F | %T | ')'$0': error mounting $PARTITION as '/lib/live/mount/findiso'."
				fi
				break
			fi
		done
	fi
	if ! [ -d /lib/live/mount/findiso ] ; then
		echo -n "\n$(date +'%F | %T | ')'$0': Local update directory not found. Exiting."
		return 0
	fi

	show_versions

	# Bandwidth limit goes here
	#
	#BWLIMITPERCENT=20 # in percent, numeric-only
	BWLIMITPERCENT=$(cat /proc/cmdline | \
				tr ' ' '\n' | \
				awk -F'=' ' /^bwlimit=/ { print $2 }')
	if [ -z "$BWLIMITPERCENT" ]; then 
		BWLIMITPERCENT=20
		echo -n "\n$(date +'%F | %T | ')'$0': Bandwidth limit not set. Defaulting to 20%."
	fi


	# sleeping a random amount of time to ease load on the update server
	#
	MAXSLEEPTIME=$(cat /proc/cmdline | \
				tr ' ' '\n' | \
				awk -F'=' ' /^updatesleep=/ && $2 ~ /^[0-9]*$/ { print $2 }')
	if [ -z "$MAXSLEEPTIME" ] || [ $MAXSLEEPTIME -lt 240 ] ; then
		MAXSLEEPTIME=900
	fi
	SLEEPTIME=0
	echo -n "\n$(date +'%F | %T | ')'$0': Calculating random update delay (120-$MAXSLEEPTIME seconds)..."
	# During startup, script is run with /bin/sh, 
	# even when #!/bin/bash is set,
	# so we need to improvise.
	RND=$(/bin/bash -c 'echo $RANDOM')
	SLEEPTIME=$((RND%MAXSLEEPTIME))
	if [ $SLEEPTIME -lt 120 ]; then
		SLEEPTIME=$((SLEEPTIME+120))
	fi
	echo -n "\n$(date +'%F | %T | ')'$0': Sleeping for $SLEEPTIME seconds ..."
	sleep $SLEEPTIME


	if ! (	[ -d "$MOUNTPOINT/boot/X2Go-live-download" ] && \
		( \
			[ -d "$MOUNTPOINT/boot/X2Go-live1" ] || \
			[ -d "$MOUNTPOINT/boot/X2Go-live2" ] \
		) \
	     ); then
		[ -n "$NTFSROOT" ] && umount $MOUNTPOINT
		echo -n "\n$(date +'%F | %T | ')'$0': No directories suitable for update."
		return 0 # directories missing, most likely not a writeable medium
	fi


	# define and figure out some paths that we will be needing later on
	#
	if [ -f "$MOUNTPOINT/syslinux.cfg" ]; then
		SYSLINUXPATH="$MOUNTPOINT/"
	elif [ -f "$MOUNTPOINT/syslinux/syslinux.cfg" ]; then
		SYSLINUXPATH="$MOUNTPOINT/syslinux/"
	elif [ -f "$MOUNTPOINT/menu.lst" ]; then
		GRUBPATH="$MOUNTPOINT/"
	elif  [ -f "$MOUNTPOINT/boot/menu.lst" ]; then
		GRUBPATH="$MOUNTPOINT/grub/"
	elif  [ -f "$MOUNTPOINT/boot/grub/menu.lst" ]; then
		GRUBPATH="$MOUNTPOINT/boot/grub/"
	else
		[ -n "$NTFSROOT" ] && umount $MOUNTPOINT
		echo -n "\n$(date +'%F | %T | ')'$0': No suitable bootloader found."
		return 1
	fi

	if [ "$RUNNINGSYSTEMNAME" = "X2Go-live1" ]; then
		OTHERSYSTEMNAME="X2Go-live2"
	elif [ "$RUNNINGSYSTEMNAME" = "X2Go-live2" ]; then
		OTHERSYSTEMNAME="X2Go-live1"
	else
		[ -n "$NTFSROOT" ] && umount $MOUNTPOINT
		echo -n "\n$(date +'%F | %T | ')'$0': Unable to determine path/name of running system."
		return 1
	fi
	OTHERSYSTEMFULLPATH=$(readlink -m "$ALLSYSTEMSROOT/$OTHERSYSTEMNAME")
	DOWNLOADPATH=$(readlink -m "$ALLSYSTEMSROOT/X2Go-live-download/")

	# Now let's figure out if we're supposed to use wget or rsync for downloading
	#
	if echo "$DOWNLOADURL" | grep -q "^http" || \
	   echo "$DOWNLOADURL" | grep -q "^ftp"
	   then
		DOWNLOADCOMMANDFORTIMESTAMP="wget -Nr -l 1 -nd -P "$TEMPDIR" \
				  --progress=bar:force \
				  $DOWNLOADURL/x2go-tce-timestamp"

		check_timestamp
		CTRC=$?
		if [ $CTRC -eq 1 ]; then
				echo -n "\n$(date +'%F | %T | ')'$0': an error occurred during timestamp download; trying full download instead ..."
		elif [ $CTRC -eq 5 ]; then
				cleanup
				echo -n "\n$(date +'%F | %T | ')'$0': Nothing to do. - Files on server not newer than '$RUNNINGSYSTEMNAME'."
				echo -n "\n$(date +'%F | %T | ')'$0': ('$RUNNINGSYSTEMNAME' is Version $RUNNINGVERSION - $(date --date=@$RUNNINGVERSION))."
				return 0 	# current is newest, nothing to do, we want to avoid
						# unneccessary writes to the medium
		else
			prepare_tempdir
		fi

		# Attempt to determine available bandwidth & to set BWLIMIT accordingly
		echo -n "\n$(date +'%F | %T | ')'$0': Attempting to determine available bandwidth for wget.\n"
		wget -Nr -P /tmp/ -nd \
			--progress=bar:force $DOWNLOADURL/x2go-tce-initrd.img 2>&1 | \
			tee /tmp/dl.log
		cp --update "/tmp/x2go-tce-initrd.img" "$TEMPDIR"
		rm "/tmp/x2go-tce-initrd.img"
		SIZEFACTORSTRING=$(	awk -F' |\(|\)' ' $9 == "saved" && \
					$7 == "-" { print $5 }' /tmp/dl.log | \
					tail -1 \
				   )
		case $SIZEFACTORSTRING in
			"" | \
			[0-9]) 	echo -n "\n$(date +'%F | %T | ')'$0': Not enough bandwidth for update task - "
				echo -n "aborting."
				cleanup
				return 0
				;;
			"KB/s") SIZEFACTOR=1;;
			"MB/s") SIZEFACTOR=1024;;
			"GB/s") SIZEFACTOR=1048576;;
			*)     	SIZEFACTOR=$((1024*1024*1024));;
		esac
		DLRATE=$(	awk -F' |\(|\)' ' $9 == "saved" && $7 == "-" \
				{ print $4 }' /tmp/dl.log | \
				tail -1
			 )
		BWLIMIT=$(	echo "$DLRATE $SIZEFACTOR $BWLIMITPERCENT" | \
				awk ' { print $1*$2*$3/100 }' | \
				awk -F'.' '{ print $1 }' \
			  ) # outputs integer kilobytes, not rounded
		echo -n "\n$(date +'%F | %T | ')'$0': Determined bandwidth limit: '$BWLIMIT KB/s'"
		DOWNLOADCOMMAND="wget -Nr -l 1 -nd -P "$TEMPDIR" \
				  --progress=bar:force \
				  --limit-rate=${BWLIMIT}k $DOWNLOADURL"

	elif echo "$DOWNLOADURL" | grep -q "^rsync"; then

		DOWNLOADCOMMANDFORTIMESTAMP="rsync -aPv --inplace $DOWNLOADURL/x2go-tce-timestamp \
				  $TEMPDIR"

		check_timestamp
		CTRC=$?
		if [ $CTRC -eq 1 ]; then
				echo -n "\n$(date +'%F | %T | ')'$0': an error occurred during timestamp download; trying full download instead ..."
		elif [ $CTRC -eq 5 ]; then
				cleanup
				echo -n "\n$(date +'%F | %T | ')'$0': Nothing to do. - Files on server not newer than '$RUNNINGSYSTEMNAME'."
				echo -n "\n$(date +'%F | %T | ')'$0': ('$RUNNINGSYSTEMNAME' is Version $RUNNINGVERSION - $(date --date=@$RUNNINGVERSION))."
				return 0 	# current is newest, nothing to do, we want to avoid
						# unneccessary writes to the medium
		else
			prepare_tempdir
		fi


		# Attempt to determine available bandwidth & to set BWLIMIT accordingly
		echo -n "\n$(date +'%F | %T | ')'$0': Attempting to determine available bandwidth for rsync.\n"
		rsync -hh -aPv -W --inplace --log-file=/tmp/dl.log $DOWNLOADURL/x2go-tce-initrd.img \
			$TEMPDIR/x2go-tce-initrd.img.new
		mv $TEMPDIR/x2go-tce-initrd.img.new $TEMPDIR/x2go-tce-initrd.img
		SIZEFACTORSTRING=$(	sed -e's_\(. bytes/sec\)_ \1_' /tmp/dl.log | \
					awk '$4 == "sent" && $12 == "bytes/sec" \
					{ print $11 }' \
				   )
		case $SIZEFACTORSTRING in
			"" | \
			[0-9]) 	echo -n "\n$(date +'%F | %T | ')'$0': Not enough bandwidth for update task - "
				echo -n "aborting."
				cleanup
				return 0
				;;
			"K")   	SIZEFACTOR=1;;
			"M")   	SIZEFACTOR=1024;;
			"G")   	SIZEFACTOR=$((1024*1024));;
			*)     	SIZEFACTOR=$((1024*1024*1024));;
		esac
		DLRATE=$(	sed -e's_\(. bytes/sec\)_ \1_' /tmp/dl.log | \
				awk '$4 == "sent" && $12 == "bytes/sec" \
				{ print $10 }')
		BWLIMIT=$(	echo "$DLRATE $SIZEFACTOR $BWLIMITPERCENT" | \
				awk ' { print $1*$2*$3/100 }' | \
				awk -F'.' '{ print $1 }' \
			  ) # outputs integer kilobytes, not rounded
		echo -n "\n$(date +'%F | %T | ')'$0': Determined bandwidth limit: '$BWLIMIT KB/s'"
		DOWNLOADCOMMAND="rsync -aPv --inplace --bwlimit=$BWLIMIT $DOWNLOADURL/ \
				  $TEMPDIR"
	else 
		[ -n "$NTFSROOT" ] && umount $MOUNTPOINT
		echo -n "\n$(date +'%F | %T | ')'$0': Unsupported download mechanism - aborting."
		return 1
	fi
	rm /tmp/dl.log



	# Proceed to download from update location
	#

	echo -n "\n$(date +'%F | %T | ')'$0': starting download ..."
	while ! $DOWNLOADCOMMAND; do
		echo -n "\n$(date +'%F | %T | ')'$0': an error occurred; sleeping 30 seconds ..."
		sleep 30
		echo -n "\n$(date +'%F | %T | ')'$0': retrying ..."
	done

	# Now check if these files are different from what we already have in our
	# download directory on the boot medium
	#
	echo -n "\n$(date +'%F | %T | ')'$0': Diff'ing '$DOWNLOADPATH' '$TEMPDIR' ..."
	if diff -q $DOWNLOADPATH $TEMPDIR \
		>/dev/null

		then
		cleanup
		echo -n "\n$(date +'%F | %T | ')'$0': Nothing to do. - Files on server not newer than '$DOWNLOADPATH'."
		return 0 	# current is newest, nothing to do, we want to avoid
				# unneccessary writes to the medium
	else
		echo -n "\n$(date +'%F | %T | ')'$0': Differences detected. Continuing ..."
	fi


	# If we made it past that point, it's time to update the boot medium, so let's
	# remount it rw and async for speed
	#
	if mount -oremount,rw,async $MOUNTPOINT; then
		echo -n "\n$(date +'%F | %T | ')'$0': Remounted '$MOUNTPOINT' as rw and async."
	else
		echo -n "\n$(date +'%F | %T | ')'$0': Could not remount '$MOUNTPOINT' as rw and async."
	fi


	# Now, we don't want to copy an index.htm(l) file, so let's do away with that
	#
	rm -f $TEMPDIR/index.ht*


	# move everything over to the boot medium
	#
	echo -n "\n$(date +'%F | %T | ')'$0': Moving $TEMPDIR/* => $DOWNLOADPATH"
	# using mv would accumulate clutter in $DOWNLOADPATH if any extra files are present in the source
	rsync -aPv --inplace --delete --modify-window=1 $TEMPDIR/ $DOWNLOADPATH/ && \
	rm -rf $TEMPDIR/*
	if [ -n "$NTFSROOT" ]; then
		echo -n "\n$(date +'%F | %T | ')'$0': NTFSROOT detected. Attempting to mount '/dev/disk/by-uuid/$NTFSROOT'."
		if mount -t ntfs-3g -rw /dev/disk/by-uuid/$NTFSROOT /lib/live/mount/ntfsroot; then
			echo -n "\n$(date +'%F | %T | ')'$0': Mount successful."
		else
			echo -n "\n$(date +'%F | %T | ')'$0': Failed to mount NTFSROOT."
		fi
	fi


	# let's check if we just downloaded a copy of our running system
	#
	echo -n "\n$(date +'%F | %T | ')'$0': Diff'ing '$DOWNLOADPATH' '$RUNNINGSYSTEMFULLPATH'"
	if diff -q $DOWNLOADPATH $RUNNINGSYSTEMFULLPATH >/dev/null && \
		   [ -d "$OTHERSYSTEMFULLPATH" ] ; then
		   [ -n "$NTFSROOT" ] && umount $MOUNTPOINT
		   echo -n "\n$(date +'%F | %T | ')'$0': Nothing to do. Content of $DOWNLOADPATH equals" \
			"$RUNNINGSYSTEMNAME."
			# now, change mount back to ro and sync
			umount_or_remount_ro
			return 0 # current is newest, nothing to do, 
				 # we want to keep the old system in OTHERSYSTEMFULLPATH
				 # as a fallback
	fi


	# make sure our destination path really exists
	#
	mkdir -p $OTHERSYSTEMFULLPATH


	# let's check if our destination is already up to date or needs updating
	#
	echo -n "\n$(date +'%F | %T | ')'$0': Diff'ing '$DOWNLOADPATH' '$OTHERSYSTEMFULLPATH'"
	if diff -q $DOWNLOADPATH $OTHERSYSTEMFULLPATH >/dev/null; then
			[ -n "$NTFSROOT" ] && umount $MOUNTPOINT
			echo -n "\n$(date +'%F | %T | ')'$0': Nothing to do - content of '$DOWNLOADPATH' equals"\
			      "'$OTHERSYSTEMNAME'."
			return 0 # OTHERSYSTEMFULLPATH is already up to date
	else
		# keep rsyncing until the update is complete
		echo -n "\n$(date +'%F | %T | ')'$0': Copying $DOWNLOADPATH/ => $OTHERSYSTEMFULLPATH ..."
		while ! rsync -aPv --inplace --modify-window=1 $DOWNLOADPATH/ $OTHERSYSTEMFULLPATH
			do
			echo -n "\n$(date +'%F | %T | ')'$0': Sleeping 30 seconds ..."
			sleep 30
			echo -n "\n$(date +'%F | %T | ')'$0': Retrying ..."
		done
		echo -n "\n$(date +'%F | %T | ')'$0': done."
		if rm -rf $DOWNLOADPATH/* ; then
			echo -n "\n$(date +'%F | %T | ')'$0': INFO: purged download directory to avoid clutter buildup."
		else
			echo -n "\n$(date +'%F | %T | ')'$0': ERROR: unable to purge download directory."
		fi
	fi

	show_versions

	# change default boot to the image we just downloaded and installed
	#
	if [ -n "$SYSLINUXPATH" ]; then
		echo -n "\n$(date +'%F | %T | ')'$0': Changing syslinux default to $OTHERSYSTEMNAME."
		sed -i -e"/^default/cdefault $OTHERSYSTEMNAME" \
			$SYSLINUXPATH/syslinux.cfg

	elif [ -n "$GRUBPATH" ]; then
		MENULST=$GRUBPATH/menu.lst
		CURRENTDEFAULT=$(awk '/^default/ { print $2 }' $MENULST | tr -d '\r')
		CURRENTTITLEPOSITION=$(grep '^title' $MENULST | 
				       grep -n "${RUNNINGSYSTEMNAME}" |
				       awk -F':' '$2 ~ /'"${RUNNINGSYSTEMNAME}"'/ { print $1 }')
		CURRENTTITLEPOSITION=$((CURRENTTITLEPOSITION-1))
		OTHERTITLEPOSITION=$(grep '^title' $MENULST |
				     grep -n "${OTHERSYSTEMNAME}" |
				     awk -F':' '$2 ~ /'"${OTHERSYSTEMNAME}"'/ { print $1 }')
		OTHERTITLEPOSITION=$((OTHERTITLEPOSITION-1))
		if [ "$CURRENTTITLEPOSITION" = "$CURRENTDEFAULT" ]; then
			echo -n "\n$(date +'%F | %T | ')'$0': Changing GRUB-legacy default to $OTHERTITLEPOSITION ..."
			sed -i -e"/^default/cdefault $OTHERTITLEPOSITION" \
				$MENULST
		else
			echo -n "\n$(date +'%F | %T | ')'$0': Not changing GRUB-legacy default."
			echo -n "\n$(date +'%F | %T | ')'$0': Reason: We're at boot position '$CURRENTTITLEPOSITION',"
			echo -n "\n$(date +'%F | %T | ')'$0': while default is set to position '$CURRENTDEFAULT'."
		fi
	else
		echo -n "\n$(date +'%F | %T | ')'$0': Unsupported bootloader."
	fi

	# we're on an async mount point, so let's sync to be safe
	#
	sync


	# umount tempdir to free memory
	#
	if [ -d $TEMPDIR ]; then
		cleanup
	fi


	# now, change mount back to ro and sync
	#
	umount_or_remount_ro

) &

}

LiveAutoUpdateMain

